/******************************************************************************************* *  Copyright Jessica C. Ramella-Roman, Steve L. Jacques and Scott A. Prahl 2005 *   *  Stok1.c -Meridian Planes MC *	Main program for Monte Carlo simulation of photon *	travelling into scattering media keeping track of  *  its status of polarization. Slab geometry. * *  by Jessica C. Ramella-Roman * *  A report in preparation illustrates use of the program: * * J. Ramella-Roman, S. A. Prahl, S. L. Jacques  *  Three Monte Carlo programs of polarized light transport into scattering media: part I, 2005 Optics Express, submitted 2005.  *  *	This program is free software; you can redistribute it and/or *	modify it under the terms of the GNU General Public License *	as published by the Free Software Foundation; either version 2 *  of the License, or (at your option) any later version. *  This program is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *  GNU General Public License for more details. *  You should have received a copy of the GNU General Public License *  along with this program; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. * * * Updated 2022 - Study of birefringence * Modified November 2022 - Leanne Iannucci for MATLAB wrapper development * ****/#include <stdio.h>#include <math.h>#include <stdlib.h>#include "array.h"#include "complex.h"#include "mie.h"#include "nrutil.h"#include <time.h>#include "mcRoutines.h"#include "saveDATs.h"#include <string.h>#include <unistd.h>#include "dataIN.h"#include "inputStruct.h"#define ALIVE      	1#define DEAD       	0#define	NN      	100#define THRESHOLD   0.01                /* used in roulette */#define CHANCE      0.1                 /* used in roulette */#define STRLEN      256                 // pulled from MCML to handle input data from txt files#define RandomNum (double) RandomGen(1, 0, NULL)#define InitRandomGen (double) RandomGen(0, 1, NULL)# include "subroutines.h"/*************** MAIN ****************************************/	int main(int argc, char *argv[]) {    const double pi = 3.1415926535897932384;/**************************************************************//*************** VARS AND SETUP *******************************//**************************************************************//* Mie theory stuff */    double radius,lambda, A;   // double A;    long nangles;    struct complex m;    struct complex *s1 = NULL;    struct complex *s2 = NULL;    int i;    double *mu = NULL;    // double x,qext,qsca,qback,g, rho, vol,dy, dx, hw;    double thick, width, length, rho;    double qext, qsca, qback, g, dy, dx, vol;    double nre_p, nim_p, nre_med, nim_med;    double alpha,delta,gama,nsmax,beta,thetax,no,ne, dn, slabsize; /*PJstuff*/    FILE *target;    int jjj;    double beamRad;/* E field stuff */    double phi, theta, I, I0;    int ithedeg;    double IT_1, QT_1, UT_1, VT_1;    double IR_1, QR_1, UR_1, VR_1;    double **IR, **QR, **UR, **VR;    double **IT, **QT, **UT, **VT;/* Propagation parameters */    double x, y, z;        /* photon position.  x already declared. Also, incrementals & max range. */    double s;          /* step sizes. s = -log(RND)/mus [cm] */    long i_photon;   /* current photon */    long    Nphotons;   /* number of photons in simulation */    short photon_status;  /*  = ALIVE=1 or DEAD=0 */    double pol, azi; /* photon launch dir*//* other variables */    double	mua;        /* absorption coefficient [cm^-1] */    double	mus;        /* scattering coefficient [cm^-1] */    double musp;       /* reduced scattering coefficient [cm^-1] */    double albedo;     /* albedo of tissue *//* dummy variables */    double rnd;        /* assigned random value 0-1 */    int MM;    MM = NN - 1;    double W, absorb;  /* photon weight */    int j, ix, iy;    double cos22, sin22, costheta, sini, cosi;/* allocate matrices and arrays */    double *U, *U2;    double *S;        /* */    double *S0;        /* */    double *S2;        /* */    double *s11 = NULL;    double *s12 = NULL;    double *s33 = NULL;    double *s43 = NULL;    double *IQUV;        /* [I, Q, U, V] Stokes Vector */    double start_time, finish_time, temp;    int jbir;/* malloc vectors and arrays */    U = new_darray(3);    U2 = new_darray(3);    S = new_darray(4);    S0 = new_darray(4);    S2 = new_darray(4);/* dummy S*/    IQUV = new_darray(4);    IR = dmatrix(0, MM, 0, MM); /* [0:MM] */    QR = dmatrix(0, MM, 0, MM); /* [0:MM] */    UR = dmatrix(0, MM, 0, MM); /* [0:MM] */    VR = dmatrix(0, MM, 0, MM); /* [0:MM] */    IT = dmatrix(0, MM, 0, MM); /* [0:MM] */    QT = dmatrix(0, MM, 0, MM); /* [0:MM] */    UT = dmatrix(0, MM, 0, MM); /* [0:MM] */    VT = dmatrix(0, MM, 0, MM); /* [0:MM] *//* Initialize out ref and trans storage */    IT_1 = 0;    QT_1 = 0;    UT_1 = 0;    VT_1 = 0;    IR_1 = 0;    QR_1 = 0;    UR_1 = 0;    VR_1 = 0;    for (iy = 0; iy < NN; iy++) {        for (ix = 0; ix < NN; ix++) {            IR[iy][ix] = 0.0;            IT[iy][ix] = 0.0;            QR[iy][ix] = 0.0;            QT[iy][ix] = 0.0;            UR[iy][ix] = 0.0;            UT[iy][ix] = 0.0;            VR[iy][ix] = 0.0;            VT[iy][ix] = 0.0;        }    }/**** end  allocate matrices and arrays *******//**************************************************************//*************** INPUT USER VARS  *****************************//**************************************************************/    start_time = clock();/* GET USER SPECIFIED VALUES FROM TXT HERE */   // char input_filename[strlen(argv[1])];    char fileOut[STRLEN];    fileOut[0] = NULL;    //strcpy(input_filename, argv[1]);    FILE* input_file_ptr;    input_file_ptr = fopen(argv[1] , "r");    if(input_file_ptr == NULL) {        printf("Error opening file");        return(-1);    }    getInputParams(input_file_ptr, &fileOut, &jjj, &thick, &width, &length, &Nphotons, &lambda, &nangles,                   &radius, &nre_p, &nim_p, &nre_med, &nim_med,                   &mus, &mua, &no, &dn, &beamRad, &pol, &azi);/**************************************************************//********************** MIE PREP  *****************************//**************************************************************//* Setup MIE SCATTERING parameters */    mu  = new_darray(nangles);    s1  = new_carray(nangles);    s2  = new_carray(nangles);    s11 = new_darray(nangles);    s12 = new_darray(nangles);    s33 = new_darray(nangles);    s43 = new_darray(nangles);    m.re = nre_p/nre_med;    m.im = 0.0;    x    = 2*pi*radius/(lambda/nre_med);   // vol  = 4.0/3*pi*radius*radius*radius;  //  A    = pi*radius*radius;    for(i=0;i<=nangles;i++) {mu[i] = cos(pi*i/nangles);}	s11=new_darray(nangles);	s12=new_darray(nangles);	s33=new_darray(nangles);	s43=new_darray(nangles);			s1=new_carray(nangles);	s2=new_carray(nangles);		Mie(x,m,mu,nangles,s1,s2,&qext,&qsca,&qback,&g); /* <---- Call Mie program ----- */	musp 	= mus*(1-g);/* [cm^-1] */	albedo 	= mus/(mus + mua);	free_darray(mu);	/*Scattering parameters s11 s12 s33 s43*/    for(i=0;i<=nangles;++i){        s11[i] = 0.5*cabbs(s2[i])*cabbs(s2[i]) + 0.5*cabbs(s1[i])*cabbs(s1[i]);        s12[i] = 0.5*cabbs(s2[i])*cabbs(s2[i]) - 0.5*cabbs(s1[i])*cabbs(s1[i]);        s33[i] = (cmul(conj(s1[i]),s2[i])).re;        s43[i] = (cmul(conj(s1[i]),s2[i])).im;        }/* set bin sizes in x and y */    dx 	= 2.0*length/NN;    dy 	= 2.0*width/NN;/**************************************************************//*************** PRINT INPUT VARS TO USER *********************//**************************************************************/    printf("Polarized Monte Carlo\ndia=%4.3f;\nmus=%4.3e;\ng=%5.5f;\nrho=%4.3e;\nmua=%4.3e;\nnphot=%2.1ld;\nbiref=%4.3e;\n",radius*2,mus,g,rho,mua,Nphotons,dn);    InitRandomGen;    genPhotonType_withPrint(jjj);/**************************************************************//****************** MONTE CARLO *******************************//**************************************************************//* LAUNCH photon */    for (i_photon = 1; i_photon <= Nphotons; i_photon++) {        /**** Create a new photon */        initPhoton(&x, &y, &z, U, S, S0, S2, &W, &photon_status, jjj, beamRad, length, width, pi, azi, pol);	        /********* ALIVE cycle *****************/		while (photon_status == ALIVE) {            /**** HOP */            doHop(mus, mua, &s, &x, &y, &z, U);            /**** ABSORB */            doAbsorb(albedo, x, y, width, length, dx, dy, &iy, &ix, &W);            /**** Rotate to reference frame */            refFrame(U, S, &phi, S2, &IR_1, &QR_1, &UR_1, &VR_1, &photon_status, thick, &IT_1, &QT_1, &UT_1, &VT_1, x, y,                     z, W, pi, MM, ix, iy, length, width, dx, dy,                     IR, QR, UR, VR, IT, QT, UT, VT);            /**** Birefringence */            if (dn != 0) {                doBiref(lambda, no, dn, U, s, pi, S, S2); // this function is empty. biref not active. see function notes for details.            }            /****** SPIN */            doSpin(theta, s11, s12, s33, s43, S, nangles, pi, U, U2, S2);			            /******* ROULETTE*/            doRoulette(&photon_status, &W);        } /* end of single photon launching */        //printf("%d\n", i_photon);    }/* no more photons*//**************************************************************//**************** Print results to console ********************//**************************************************************/printf("R: I %5.5f\t Q %5.5f\t U %5.5f\t V %5.5f\n", IR_1 / (Nphotons), QR_1 / (Nphotons), UR_1 / (Nphotons), VR_1 / (Nphotons));printf("T: I %5.5f\t Q %5.5f\t U %5.5f\t V %5.5f\n", IT_1 / (Nphotons), QT_1 / (Nphotons), UT_1 / (Nphotons), VT_1 / (Nphotons));/**************************************************************//****************** SAVING THINGS *****************************//**************************************************************/saveDatFile(0, jjj-1, 0, NN, IR);saveDatFile(1, jjj-1, 0, NN, QR);saveDatFile(2, jjj-1, 0, NN, UR);saveDatFile(3, jjj-1, 0, NN, VR);saveDatFile(0, jjj-1, 1, NN, IT);saveDatFile(1, jjj-1, 1, NN, QT);saveDatFile(2, jjj-1, 1, NN, UT);saveDatFile(3, jjj-1, 1, NN, VT);/**************************************************************//**************** Print TIME to console ***********************//**************************************************************/finish_time= clock();printf("Elapsed Time = %10.2f seconds\n", (double)(finish_time-start_time)/CLOCKS_PER_SEC);	fflush(NULL);    return 0;} /* main routine*//**************************************************************//*************** end MAIN ************************************//**************************************************************/